/*
描述
Yougth和Hrdv玩一个游戏，拿出n个石子摆成一圈，Yougth和Hrdv分别从其中取石子，
谁先取完者胜，每次可以从中取一个或者相邻两个，Hrdv先取，输出胜利着的名字。

输入
输入包括多组测试数据。
每组测试数据一个n，数据保证int范围内。
输出
输出胜利者的名字。
样例输入
2
3
样例输出
Hrdv
Yougth
*/
#include <stdio.h>

main()
{
	int n;
	
	while(scanf("%d",&n)!=EOF)
	{
		if(n<3)
		printf("Hrdv\n");
		else
		printf("Yougth\n"); 
	}
	
	return 0;
}
/*
思路：已知石头是为圈，即H先取1或2之后剩下的都是一条线
Exempli Gratia：（1）123456789取5剩67891234，（2）取78剩9123456
若n>3，Y要赢则只需将线取对称即可，如上Y（1）取91剩678和234
（2）取3剩912和456，如此下去Y赢

扩展：将原题改为“每次取一个或者两个”，则原题可以理解为巴什博奕问题 
#include <stdio.h>

main()
{
	int n;
	
	while(scanf("%d",&n)!=EOF)
	{
		if(n%3==0)
		printf("Yougth\n");
		else
		printf("Hrdv\n"); 
	}
	
	return 0;
}
巴什博奕（Bash Game）：只有一堆n个物品，两个人轮流从这堆物品中取物，
规定每次至少取一个，最多取m个。最后取光者得胜。
显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，
后取者都能够一次拿走剩余的物品，后者取胜。
因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),
那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，
结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。
总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 
*/
